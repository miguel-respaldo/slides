% ex: ts=2 sw=2 sts=2 et filetype=tex
% SPDX-License-Identifier: CC-BY-SA-4.0


\section{La filosofía de las herramientas de Unix}

\begin{frame}[c]{¿Qué es un comando Linux?}
  \begin{itemize}
    \item Un comando Linux es un programa o utilidad que se ejecuta en la CLI,
      una consola que interactúa con el sistema a través de textos y procesos.
      Es similar a la aplicación Símbolo del Sistema en Windows.
    \item Los comandos de Linux se ejecutan en el Terminal pulsando Enter al
      final de la línea. Puedes ejecutar comandos para realizar diversas
      tareas, desde la instalación de paquetes hasta la gestión de usuarios
      y la manipulación de archivos.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sintaxis}
  La sintaxis general de un comando Linux es la siguiente:

  \begin{lstlisting}[language=Bash]
NombreDelComando [opcion(es)] [parametro(s)]
  \end{lstlisting}

  \vspace{\baselineskip}
  Los comandos Linux pueden contener una \textbf{opción o un parámetro}.
  En algunos casos, pueden ejecutarse sin ellos. Estas son las tres partes
  más comunes de un comando:

  \vspace{\baselineskip}
  \begin{description}
    \item [NombreDelComando] es la regla que desea ejecutar.
    \item [opciones o vanderas] modifica el funcionamiento de un comando.
      Para ejecutarla, utiliza guiones (-) o guiones dobles (--).
    \item [parametros o argumentos] especifica cualquier información
      necesaria para el comando.
  \end{description}
\end{frame}

\begin{frame}[c]{Sintaxis}
  \begin{alertblock}{Nota:}
    Ten en cuenta que todos los comandos de Linux distinguen entre mayúsculas y minúsculas.
  \end{alertblock}
\end{frame}

\begin{frame}[c]{La filosofía de las herramientas de Unix}
  \begin{itemize}
    \item Una herramienta es un programa simple, generalmente diseñado para un
      propósito específico, a veces se le denomina como un comando.

    \pausa
    \item La filosofía de herramientas de Unix, surge durante la creación del
      sistema operativo UNIX, después de la revolucionaria invención del
      tubo (o tubería) '|'.

    \pausa
    \item La tubería permitía enviar la \textbf{salida} de un programa a la
      \textbf{entrada} de otro. La filosofía de las herramientas era tener
      \textbf{pequeños programas} para realizar una \textbf{tarea
      particular} en lugar de tratar de desarrollar grandes
      programas monolíticos para realizar una gran cantidad de tareas.

      Para realizar tareas más complejas, las herramientas simplemente se
      conectarían entre sí mediante tuberías.
  \end{itemize}
\end{frame}

\begin{frame}[c]{La filosofía de las herramientas de Unix}
  \begin{itemize}
    \item Todas las herramientas básicas del sistema UNIX se diseñaron para
      que pudieran operar juntas. Los editores originales basados en texto (e
      incluso TeX y LaTeX) usaban ASCII y ahora usan UTF-8 y puede usar
      herramientas como: \textbf{sed, awk, vi, grep, cat, more, tr} y
      varias otras herramientas basadas en texto junto con estos editores.

    \pausa
    \item Usando esta filosofía, los programadores evitaron escribir un
      programa (dentro de su programa más grande) que ya había sido escrito
      por otra persona (esto podría considerarse una forma de reciclaje de
      código). Por ejemplo, varias aplicaciones diferentes utilizan los
      correctores ortográficos de la línea de comandos en lugar de que cada
      aplicación cree su propio corrector ortográfico.

    \pausa
    \item Esta filosofía vive hoy en GNU/Linux y varios otros sistemas
      operativos basados en el sistema UNIX (FreeBSD, NetBSD, OpenBSD, etc.).
  \end{itemize}
\end{frame}

\section{Manuales y Ayuda}

\begin{frame}[c]{Comando man}
  \begin{description}
    \item[Nombre]
      \textbf{man} - interfaz de los manuales de referencia del sistema

    \vspace{\baselineskip}
    \item[Sinopsis]
      man [opciones de man] [[sección] página ...] ... \\
      man -K [opciones de man] [sección] term ... \\
      man -f [opciones de whatis] página ... \\

    \vspace{\baselineskip}
    \item[Descripción]
      man es el paginador de manuales del sistema.
      Cada argumento de página dado a man normalmente es el nombre de un
      programa, utilidad o función. La página de manual asociada con cada
      uno de estos argumentos es, pues, encontrada y mostrada.

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item man ls
        \item man -K ssh
        \item man -f scp
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando info}
  \begin{description}
    \item[Nombre]
      \textbf{info} - lee los documentos Info

    \vspace{\baselineskip}
    \item[Sinopsis]
      info [opciones] ... [menu-item ... ]

    \vspace{\baselineskip}
    \item[Descripción]
      Lee la documentación que se encuentra en formato Info.

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item info emacs
        \item info -f ./archivo.info
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando whatis}
  \begin{description}
    \item[Nombre]
      \textbf{whatis} - muestra descripciones de una línea de las páginas
      de manual

    \vspace{\baselineskip}
    \item[Sinopsis]
      whatis [-dlv?V] [-r|-w] [-s lista] [-m sistema[,...]] [-M ruta] [-L localización] [-C archivo] nombre ...
    \vspace{\baselineskip}
    \item[Descripción]
      Cada página de manual despone de una descripción breve. whatis busca
      nombres de página de manual y muestra las descripciones de página de
      cualquier nombre coincidente.

      El nombre puede contener comodines (-w) o puede ser una expresión
      regular (-r). Con estas opciones puede ser necesario entrecomillar el
      nombre o escapar (\textbackslash{}) los caracteres especiales para impedir que la
      shell los interprete.

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item whatis ls
        \item whatis ssh
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando apropos}
  \begin{description}
    \item[Nombre]
      \textbf{apropos} - busca nombres y descripciones de páginas de manual

    \vspace{\baselineskip}
    \item[Sinopsis]
      apropos [-dalv?V] [-e|-w|-r] [-s listado] [-m sistema[,...]] [-M ruta] [-L local] [-C archivo] palabraclave ...

    \vspace{\baselineskip}
    \item[Descripción]
      Cada página de manual contiene una breve descripción.
      apropos busca las descripciones de las instancias de palabra clave.

      Una palabraclave normalmente es una expresión regular, como si (-r)
      fuera empleada, o quizá contenga comodines (-w), o coincida con la
      palabra clave exacta (-e). Utilizando estas opciones, quizá sea
      necesario entrecomillar la palabraclave o escapar (\textbackslash{})
      los caracteres especiales para impedir que la shell los interprete.

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item apropos ssh
      \end{itemize}
  \end{description}
\end{frame}

\section{Comandos más usados}

\begin{frame}[c]{Comando ls}
  \begin{description}
    \item[Nombre]
      \textbf{ls} - lista el contenido de un directorio

    \vspace{\baselineskip}
    \item[Sinopsis]
      ls [opciones] ... [ARCHIVO] ...

    \vspace{\baselineskip}
    \item[Descripción]
      Por  defecto,  muestra  información de los ARCHIVO (pueden ser uno o
      varios) del directorio actual. Ordena alfabéticamente la salida si no
      se especifica ninguna de las opciones -cftuvSUX ni --sort.

      \begin{itemize}
        \item [-a] no oculta las entradas que comienzan con .
        \item [-l] utiliza un formato de listado largo
        \item [-R] muestra los subdirectorios recursivamente
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item ls -l  /
        \item ls -la \$HOME
        \item ls -R  /etc
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando cd}
  \begin{description}
    \item[Nombre]
      \textbf{cd} - cambia de directorio

    \vspace{\baselineskip}
    \item[Sinopsis]
      cd [-L|[-P [-e]] [-@]] [dir]

    \vspace{\baselineskip}
    \item[Descripción]
      Cambia el cual directorio al directorio \emph{dir}. Si no se
      especifica \emph{dir}, el valor de la variable \textbf{HOME} es usado.

      \begin{itemize}
        \item [-L] sigue los enlaces simbólicos y se cambia a este
          directorio.
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item cd
        \item cd /etc
        \item cd /tmp
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando pwd}
  \begin{description}
    \item[Nombre]
      \textbf{pwd} - imprime el nombre del directorio de trabajo actual (print working directory)

    \vspace{\baselineskip}
    \item[Sinopsis]
      pwd [opciones]

    \vspace{\baselineskip}
    \item[Descripción]
      Muestra la ruta completa del directorio de trabajo actual.

      \begin{itemize}
        \item [-L] utiliza PWD del entorno, incluso si contiene enlaces
          simbólicos
        \item [-P] evita todos los enlaces simbólicos
      \end{itemize}

      \vspace{\baselineskip}
      Si no se especifica ninguna opción, se supone -L.

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item pwd
        \item pwd -P
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando cat}
  \begin{description}
    \item[Nombre]
      \textbf{cat} - concatenar archivos e imprimir en la salida estándar

    \vspace{\baselineskip}
    \item[Sinopsis]
      cat [opciones] ... [ARCHIVO] ...

    \vspace{\baselineskip}
    \item[Descripción]
      Concatenar ARCHIVO(s) a la salida estándar. \\
      Sin ARCHIVO, o cuando el ARCHIVO es -, lee la entrada estándar.

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item cat /etc/passwd
        \item cat -
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando cp}
  \begin{description}
    \item[Nombre]
      \textbf{cp} - copiar archivos y directorios

    \vspace{\baselineskip}
    \item[Sinopsis]
      cp [opciones] ... [-T] ORIGEN DESTINO \\
      cp [opciones] ... ORIGEN ... DIRECTORIO \\
      cp [opciones] ... -t DIRECTORIO  ORIGEN ...

    \vspace{\baselineskip}
    \item[Descripción]
      Copia ORIGEN a DESTINO, o varias ORIGEN(es) a DIRECTORIO.

      \begin{itemize}
        \item [-a] igual que -dR --preserve=all
        \item [-i] pregunta antes de sobrescribir (anula una opción -n
          anterior)
        \item [-r] copiar directorios recursivamente
        \item [-v] explicar lo que se está haciendo
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item cp /etc/passwd /tmp/passwords
        \item cp /etc/passwd /usr/bin/ls /tmp
        \item cp -r /etc /tmp
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando mv}
  \begin{description}
    \item[Nombre]
      \textbf{mv} - mueve (renombra) archivos

    \vspace{\baselineskip}
    \item[Sinopsis]
      mv [opciones] ... [-T]  ORIGEN  DESTINO \\
      mv [opciones] ... ORIGEN ... DIRECTORIO \\
      mv [opciones] ... -t DIRECTORIO  ORIGEN ...

    \vspace{\baselineskip}
    \item[Descripción]
      Copia ORIGEN a DESTINO, o varios ORIGEN(es) a DIRECTORIO.

      \begin{itemize}
        \item [-f] no pregunta nunca antes de sobreescribir
        \item [-i] pide confirmación antes de sobreescribir
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item mv archivo.txt /tmp/passwords
        \item mv /tmp/passwords /tmp/passwords2
        \item mv -i /tmp/passwords2 /tmp/passwords3
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando mkdir}
  \begin{description}
    \item[Nombre]
      \textbf{mkdir} - crea directorios

    \vspace{\baselineskip}
    \item[Sinopsis]
      mkdir [opciones] ... DIRECTORIO

    \vspace{\baselineskip}
    \item[Descripción]
      Crea los DIRECTORIO(s), si no existen aún.

      \begin{itemize}
        \item [-p] no hay error si existen, crea los directorios
          padres en caso necesario
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item mkdir /tmp/uno
        \item mkdir -p /tmp/uno/dos/tres
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando rmdir}
  \begin{description}
    \item[Nombre]
      \textbf{rmdir} - borra directorios vacíos

    \vspace{\baselineskip}
    \item[Sinopsis]
        rmdir [OPCIÓN]... DIRECTORIO...

    \vspace{\baselineskip}
    \item[Descripción]
      Borra el/los DIRECTORIO(s), si están vacíos.

      \begin{itemize}
        \item [-p] Elimina DIRECTORIO y sus prdecesores; por ejemplo
          'rmdir -p a/b/c' es lo mismo que 'rmdir a/b/c a/b a'
        \item [-v] muestra un mensaje por cada archivo procesado
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item rmdir /tmp/uno/dos/tres
        \item rmdir -p /tmp/uno
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando rm}
  \begin{description}
    \item[Nombre]
      \textbf{rm} - borra archivos o directorios

    \vspace{\baselineskip}
    \item[Sinopsis]
      rm [OPCIÓN]... [ARCHIVO]...

    \vspace{\baselineskip}
    \item[Descripción]
      Esta aplicación elimina cada uno de los archivos dados. Por defecto,
      no elimina directorios.

      Si se dan las opciones -I, o --interactive=once; si hay más de tres
      archivos o se dan las opciones -r, -R, o --recursive, rm pregunta al
      usuario cómo proceder con la orden dada. Si no la respuesta no es
      afirmativa, no se ejecuta nada.

      \begin{itemize}
        \item [-f] descarta los ficheros y argumentos que no existan,
          sin preguntar
        \item [-i] pregunta antes de cada borrado
        \item [-r] borra los contenidos de los directorios recursivamente
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item rm /tmp/uno/dos/tres/archivo.txt
        \item rm -rf /tmp/uno
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando sudo}
  \begin{description}
    \item[Nombre]
      \textbf{sudo} - ejecuta un comando como otro usuario

    \vspace{\baselineskip}
    \item[Sinopsis]

    \vspace{\baselineskip}
    \item[Descripción]
      sudo permite a un usuario autorizado ejecutar un comando como
      superusuario u otro usuario, según lo especificado por la política de
      seguridad.

      \begin{itemize}
        \item [-E] preserva las variables de entorno del usuario
        \item [-i] Simula un login inicial y corre una nueva linea de
          comandos con el nuevo usuario.
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item sudo -i
        \item sudo -i -u otroUsuario
        \item sudo fdisk -l
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando touch}
  \begin{description}
    \item[Nombre]
      \textbf{touch} - cambia la fecha de un archivo

    \vspace{\baselineskip}
    \item[Sinopsis]
      touch [OPCIÓN]... ARCHIVO...

    \vspace{\baselineskip}
    \item[Descripción]
      Actualiza la fecha de acceso y modificación de cada ARCHIVO a la hora
      actual.

      Si no existe el argumento ARCHIVO , se creará uno vacío, a menos que
      se especifique -c o -h.

      \begin{itemize}
        \item [-c] no crea ningún archivo
        \item [-h] afecta a cada enlace simbólico en lugar de a los
          archivos referidos
        \item [-a] cambia solamente la fecha de acceso
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item touch /tmp/holamundo
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando find}
  \begin{description}
    \item[Nombre]
      \textbf{find} - busca archivos en una jerarquia de directorios

    \vspace{\baselineskip}
    \item[Sinopsis]
      find  [-H]  [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]

    \vspace{\baselineskip}
    \item[Descripción]
      Busca en el árbol de directorios enraizado en cada punto de partida
      dado evaluando la expresión dada de izquierda a derecha, de acuerdo
      con las reglas de precedencia, hasta que se conoce el resultado,
      momento en el que buscar pasa al siguiente nombre de archivo.

      Si no se especifica ningún punto de partida, `.' se supone.

      \begin{itemize}
        \item [-P] No sigue los enlaces simbólicos
        \item [-L] Si sigue los enlaces simbólicos
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item find -name nombredearchivo.txt
        \item find ./ -type d -name nombredeldirectorio
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando grep}
  \begin{description}
    \item[Nombre]
      \textbf{grep, egrep, fgrep - rgrep} - muestran líneas que concuerdan
      con un patrón

    \vspace{\baselineskip}
    \item[Sinopsis]
      grep [OPCIÓN...] PATRONES [ARCHIVO...] \\
      grep [OPCIÓN...] -e PATRONES ... [ARCHIVO...] \\
      grep [OPCIÓN...] -f ARCHIVO\_PATRÓN ... [ARCHIVO...]

    \vspace{\baselineskip}
    \item[Descripción]
      grep busca PATRONES en cada ARCHIVO. PATRONES consistirá en uno o más
      patrones separados entre sí por un salto de línea; grep mostrará cada
      línea donde encuentre una concordancia con dicho patrón. En general,
      deben entrecomillarse los patrones si se ejecut grep dentro de otra
      orden de la shell.

      \begin{itemize}
        \item [-E] interpreta PATRONES como una expresión regular extendida
        \item [-F] Interpreta PATRONES como una cadena de texto, no como
          expresiones regulares.
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item grep azul notepad.txt
        \item ps aux | grep gnome
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando df}
  \begin{description}
    \item[Nombre]
      \textbf{df} - informa de la utilización del espacio de disco en
      sistemas de ficheros

    \vspace{\baselineskip}
    \item[Sinopsis]
      df [OPCIÓN]... [FICHERO]...

    \vspace{\baselineskip}
    \item[Descripción]
      df muestra el nivel de uso del sistema de archivos que contiene a cada
      archivo que se especifica como argumento. Si no se proporciona ningún
      nombre de archivo, se muestra el nivel de uso del espacio en todos los
      sistemas de archivos montados.

      \begin{itemize}
        \item [-h] muestra los tamaños en potencias de 1024 (p.e. 1023M)
        \item [-i] muestra la información de nodos-i en lugar del uso de
          bloques
        \item [-T] muestra el tipo del sistema de ficheros
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item df -h
        \item df -T
      \end{itemize}
  \end{description}
\end{frame}

\begin{frame}[c]{Comando du}
  \begin{description}
    \item[Nombre]
      \textbf{du} - estima el uso de espacio de ficheros

    \vspace{\baselineskip}
    \item[Sinopsis]
      du [OPCIÓN]... [FICHERO]... \\
      du [OPCIÓN]... --files0-from=F

    \vspace{\baselineskip}
    \item[Descripción]
      Muestra un resumen del uso de disco para el conjunto dado de ARCHIVOS,
      en el caso de los directorios lo hará de forma recursiva.

      \begin{itemize}
        \item [-a] muestra resultados para todos los ficheros,
          no solo para los directorios
        \item [-s] muestra solamente un total para cada argumento
        \item [-h] muestra los tamaños de forma legible (p. ej., 1K 234M 2G)
      \end{itemize}

    \vspace{\baselineskip}
    \item[Ejemplos]
      \begin{itemize}
        \item du /tmp
        \item du -sh \$HOME
      \end{itemize}
  \end{description}
\end{frame}


\section{Comodines/Wildcards}

\begin{frame}[c]{Comodines}
  Los comodines son útiles de muchas maneras para un sistema GNU/Linux y
  para varios otros usos. Los comandos pueden usar comodines para actuar
  en más de un archivo a la vez,o para encontrar parte de una frase en un
  archivo de texto.

  \vspace{\baselineskip}
  Hay muchos usos para los comodines, hay dos formas diferentes importantes
  en que se usan los comodines, estos son englobando (globbing)
  patrones/comodines estándar que a menudo usa el shell.

  \vspace{\baselineskip}
  La otra alternativa es expresiones regulares, popular con muchos otros
  comandos y popular para usarla con la búsqueda de textos y su
  manipulación.
\end{frame}

\begin{frame}[c]{Comodines estándar (patrones globales)}
  Varias utilidades de línea de comandos utilizan comodines estándar
  (también conocidos como patrones globales) para trabajar con varios
  archivos.

  \vspace{\baselineskip}
  Los comodines estándar se utilizan en casi cualquier comando
  (incluidos mv, cp, rm y muchos otros).

  \begin{description}
    \item[?] (signo de interrogación) esto puede representar cualquier
      carácter individual . Si especificó algo en la línea de comando
      como "hd?" GNU/Linux buscaría hda, hdb, hdc y cualquier otra
      letra/número entre az, 0-9.
  \end{description}
\end{frame}

\begin{frame}[c]{Comodines estándar (patrones globales)}
  \begin{description}
    \item[*] (asterisco) esto puede representar cualquier número de
      caracteres (incluido cero; en otras palabras, cero o más caracteres).
      Si especificaste un "cd*", usaría "cda", "cdrom", "cdrecord" y
      cualquier cosa que comience con "cd", incluido también el propio "cd".
      "m*l" podría ser mill, mull, ml y cualquier cosa que comience con m y
      termine con l.
  \end{description}
\end{frame}

\begin{frame}[c]{Comodines estándar (patrones globales)}
  \begin{description}
    \item[ [ ] (corchetes) especifica un rango. Si hiciste m$[a,o,u]$m puede
      convertirse en: mam, mum, mom si hiciste: m$[ad]$m puede convertirse en
      cualquier cosa que comience y termine con my tenga cualquier carácter
      entre a y d en el medio. Por ejemplo, estos funcionarían: mam, mbm,
      mcm, mdm. Este tipo de comodín especifica una relación "o" (sólo
      necesita que coincida una).
    \item[\{ \}] (llaves) Los términos están separados por comas y cada
      término debe ser el nombre de algo o un comodín. Este comodín copiará
      todo lo que coincida con los comodines o con los nombres exactos (una
      relación "o", uno u otro). Ejemplo: cp \{*.doc,*.pdf\} ~
  \end{description}
\end{frame}

\section{Direccionamiento de entrada/salida}

\begin{frame}[c]{Conceptos}
  Las tres definiciones siguientes se denominan "\textbf{Flujos de archivos}".
  Contienen información que se recibe de algún lugar o se envía a algún lugar.
  En un sistema UNIX, la entrada del teclado (\textbf{entrada estándar}),
  la información impresa en la pantalla (\textbf{salida estándar}) y la
  \textbf{salida de error} (también impresa en la pantalla) se tratan como
  flujos de archivos separados.
\end{frame}

\begin{frame}[c]{Flujos de archivos}
  \begin{description}
    \item[Salida estándar]
      La salida estándar es la salida del programa impresa en la pantalla,
      sin incluir la salida de error (ver más abajo).
    \pausa
    \vspace{\baselineskip}
    \item[Entrada estándar]
      La entrada estándar es la entrada del usuario. Normalmente, el teclado
      se utiliza como dispositivo de entrada estándar en un sistema UNIX.
    \pausa
    \vspace{\baselineskip}
    \item[Error estándar]
      El error estándar es la salida de error de los programas. Esta salida
      también se envía a la pantalla y normalmente se verá mezclada con la
      salida estándar. La diferencia entre la salida estándar y el error
      estándar es que el error estándar no tiene búfer (aparece
      inmediatamente en la pantalla) y el error estándar solo se imprime
      cuando algo sale mal (le dará detalles de lo que salió mal).
  \end{description}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uso de los flujos de archivos}

  \begin{description}
    \item[>]
      El símbolo mayor que se usa para enviar información a algún lugar
      (por ejemplo, un archivo de texto).

      \begin{lstlisting}[language=Bash]
cat archivo1.txt archivo2.txt > archivo1_y_2.txt
      \end{lstlisting}

      Esto concatenará los archivos en un archivo grande llamado
      "archivo1\_y\_2.txt". Tenga en cuenta que esto sobrescribirá
      cualquier archivo existente.

    \pausa
    \vspace{\baselineskip}
    \item[<]
      El símbolo menor que insertará información de algún lugar (un archivo
      de texto) como si lo hubiera escrito usted mismo. A menudo se usa con
      comandos que están diseñados para obtener información solo de la
      entrada estándar.

      \begin{lstlisting}[language=Bash]
tr 'a-z' 'A-Z' < unArchivo.txt > archivoNuevo.txt
# de minúsculas a mayúsculas
tr '[:lower:]' '[:upper:]' < unArchivo.txt > archivoNuevo.txt
      \end{lstlisting}
  \end{description}
\end{frame}

\begin{frame}[c]{Uso de los flujos de archivos}
  \begin{description}
    \item[>{}>]
      El símbolo \textbf{>{}>} agrega información al final de un archivo o
      crea una si el archivo no existe.
  \end{description}
\end{frame}

\begin{frame}[c]{Uso de los flujos de archivos}
  \begin{description}
    \item[<{}<]
      El símbolo \textbf{<{}<} a veces se usa con comandos que usan entrada
      estándar para tomar información. Simplemente escriba \textbf{<{}<
      palabra} (donde palabra puede ser cualquier cadena) al final del
      comando. Sin embargo, su uso principal es en secuencias de comandos de
      shell.

      \vspace{\baselineskip}
      El comando toma su entrada hasta que escribe "palabra",
      lo que hace que el comando finalice y procese la entrada.

      \vspace{\baselineskip}
      Usar << es similar a usar \textbf{CTRL-D} (tecla \textbf{EOF}),
      excepto que usa una cadena para realizar la función de fin de archivo.
      Este diseño permite su uso en scripts de shell.
  \end{description}
\end{frame}

\begin{frame}[c]{Uso de los flujos de archivos}
  \begin{description}
    \item[]
      \vspace{\baselineskip}
      Por ejemplo, escriba "\textbf{cat}" (sin opciones...) y funcionará con
      la entrada estándar.

      \vspace{\baselineskip}
      Para dejar de ingresar la entrada estándar, normalmente presionaría
      \textbf{CTRL-D}.

      \vspace{\baselineskip}
      Como alternativa, puede escribir "cat <{}< TERMINADO", luego escriba lo
      que desee.

      \vspace{\baselineskip}
      Cuando haya terminado, en lugar de presionar \textbf{CTRL-D}, puede
      escribir "TERMINADO" y terminará (la palabra TERIMANDO no se grabará).
  \end{description}
\end{frame}


\section{Gestión de usuarios}

\begin{frame}[c]{....}
  \begin{center}
    mmmm ... y porque no mejor usamos \textbf{man}
  \end{center}
\end{frame}

%\section{Herramientas relacionadas con el texto}
%
%\begin{frame}[c]{....}
%  \begin{center}
%    mmmm ... y porque no mejor usamos \textbf{man}
%  \end{center}
%\end{frame}
%
%\section{Comandos de red}
%\section{Seguridad}
%\section{Archivar archivos}

